---
title: "Introduction to SOLNP"
output: 
    rmarkdown::html_vignette:
        css: custom.css
        code_folding: show
vignette: >
  %\VignetteIndexEntry{Introduction to SOLNP}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE}
library(Rsolnp)
```

## Introduction

The SOLNP algorithm, first proposed by Ye (1988), is a Sequential Quadratic Programming (SQP) approach designed to solve general nonlinear optimization problems with both equality and inequality constraints. In 2010, it was implemented in R as the Rsolnp package, originally to fill the need for a robust and flexible constrained optimizer required by the author’s own GARCH modeling package, [rugarch](https://cran.r-project.org/package=rugarch). Since then, Rsolnp has remained one of the few readily available and user-friendly options for nonlinear constrained optimization in R.

Despite the growth of R’s ecosystem in statistics and data science, the development and availability of modern nonlinear constrained optimization solvers in R has lagged behind other languages. Notable exceptions are [nloptr](https://cran.r-project.org/package=nloptr) (which wraps NLopt solvers) and [ipoptr](https://github.com/jyypma/ipoptr) (an R interface to the IPOPT solver)^[the latter is no longer available on CRAN due to licensing issues]. However, overall progress in this area has been limited over the past decade.

Meanwhile, Python and Julia have rapidly integrated state-of-the-art optimization libraries, either through direct development or robust bindings to leading solvers. In contrast, many advanced solvers are now primarily developed for Python, or have R wrappers that are often unmaintained, incomplete, or limited by licensing restrictions.

In the nonlinear programming (NLP) space, most state-of-the-art solvers remain closed source and commercial, in contrast to other algorithmic advances that have transitioned from academia to open-source availability.

## Problem Statement

The general nonlinear optimization problem addressed by SOLNP can be stated as follows:

$$
\begin{align}
& \min_{x \in \mathbb{R}^n} \quad f(x) \\\\
& \text{subject to:} \\\\
& \quad l_g \leq g(x) \leq u_g \qquad \text{(general inequality constraints)} \\\\
& \quad h(x) = B \qquad \text{(equality constraints with bound vector \(B\))} \\\\
& \quad x^L \leq x \leq x^U \qquad \text{(variable bounds)}
\end{align}
$$

where:

 - $f(x)$: Nonlinear objective function to minimize
 - $g(x)$: Vector of general nonlinear inequality constraint functions, with lower and upper bounds $l_g$, $u_g$
 - $h(x)$: Vector of nonlinear equality constraint functions, required to be equal to vector B
 - $x^L$, $x^U$: Lower and upper bounds for the variables

Note:

 - Standard equality constraints of the form $h(x) = 0$ can be recovered by setting B = 0.
 - General inequality constraints allow for two-sided bounds (e.g., $l_g < g(x) < u_g$), 
 not just upper or lower bounds individually.


### Inequalities

Each inequality constraint $l_i \leq g_i(x) \leq u_i$ is transformed into two 
equality constraints via slack variables. Introduce slack variable $s_i \geq 0$, 
then define:

$$
h_i(x, s_i) = g_i(x) - s_i = l_i \quad \text{if } g_i(x) \geq l_i \\
h_i(x, s_i) = g_i(x) + s_i = u_i \quad \text{if } g_i(x) \leq u_i
$$


This can be unified into:

$$
g_i(x) - s_i = l_i \quad \text{and} \quad g_i(x) + s_i = u_i
$$


So every bounded inequality becomes an equality constraint with a slack, and the 
slack becomes part of the optimization variable vector.

In the actual implementation, if a constraint is double-bounded, a 
"penalty equality constraint" is introduced $h_i(x, s_i) := g_i(x) - s_i = m_i$
and add a penalty term to objective if $s_i < 0$.

### Slack Variable Embedding

The augmented optimization vector becomes:

$\tilde{x} = \begin{bmatrix} x \\ s \end{bmatrix}$

And the original constraints are reformulated into a system of equalities only:

$$
\tilde{g}(x, s) =
\begin{bmatrix}
g_{\text{eq}}(x) \\
g_{\text{ineq}}(x) - s - l \\
g_{\text{ineq}}(x) + s - u
\end{bmatrix} = 0
$$

### Optimization via Augmented Lagrangian

Unlike traditional SQP, SOLNP does not explicitly solve the KKT system. 
Instead, it uses a partial augmented Lagrangian:

$$
L(x, \lambda, \rho) = f(x) + \lambda^\top g(x) + \frac{\rho}{2} \|g(x)\|^2
$$

where:

  - $g(x)$ contains only equality constraints (as inequalities are transformed)
  - $\lambda$ are Lagrange multipliers (estimated iteratively)
  - $\rho$ is the penalty parameter

### No Stationarity-Based KKT Step

Unlike SQP or interior-point methods, SOLNP does not solve the full KKT system 
at each iteration, instead using: 
  - a quadratic local model
  - a trust-region style step
  - penalty-based adjustment (via $\rho$)

The stationarity check is only implicit in terms of convergence of $\nabla f + J^\top \lambda \to 0$, 
not enforced directly.

### Why Higher Tolerances Are Not Preferred

In many optimization algorithms, users are tempted to relax convergence tolerances 
(e.g., tol = 1e-4 instead of 1e-8) to achieve faster convergence. However, in SOLNP, 
doing so can compromise both feasibility and solution quality, due to the algorithm’s 
reliance on penalty-based convergence rather than exact stationarity.


## C++ Version

The original solnp function did not make use of analytic gradients or Jacobians,
and was written entirely in R, a direct translation from the Matlab code. Since 
version 1.2.0, a new function csolnp, written in C++^[Using [Rcpp](https://cran.r-project.org/package=Rcpp) 
and [RcppArmadillo](https://cran.r-project.org/package=RcppArmadillo)] allows the user 
to provide analytic gradient and/or Jacobians for the inequality and
equality constraints. In the absence of analytic functions, finite differences are
used using the scaffolding from the [numDeriv](https://cran.r-project.org/package=numDeriv) package.

The function signature for the csolnp function is now slightly different from that
of solnp in both content and code styling:

```{r}
args(csolnp)
```

vs 

```{r}
args(solnp)
```


Speedup of anywhere up to 10x can be expected for some problems. Additionally,
certain enhancements have been made in the C++ code in regards to criteria for
early termination to avoid stalling in the line search phase.


## Test Suite

As of version 1.2.0, a new test suite based on @Hock1980 and @Schittkowski2012
has been included, translated from the Fortran codes 
[here](https://klaus-schittkowski.de/tpnp.htm). Currently, about 100 problems
of the 306 have been translated, and it is the intention of the author to 
eventually translate all the tests.

Each test, returns a list with the following information:

 - fn : the objective function
 - gr : the analytic gradient function
 - eq_fn : the equality function
 - eq_b : the equality bounds
 - eq_jac : the Jacobian of the equality function
 - ineq_fn : the inequality function
 - ineq_lower : the lower bounds for the inequalities
 - ineq_upper : the upper bounds for the inequalities
 - ineq_jac : the Jacobian of the inequality function
 - lower : lower parameter bounds
 - upper : upper parameter bounds
 - start : initialization parameters
 - best_fn : best known optimal objective
 - best_par : best known optimal parameters
 - name : test name
 
The suite can be called at once or by reference to a specific test, as illustrated
below.

```{r}
prob <- solnp_problem_suite(number = 10)
sol <- csolnp(pars = prob$start, fn = prob$fn, gr = prob$gr, eq = prob$eq_fn, eq_b = prob$eq_b, 
              eq_jac = prob$eq_jac, ineq_fn = prob$ineq_fn, ineq_lower = prob$ineq_lower, 
              ineq_upper = prob$ineq_upper, ineq_jac = prob$ineq_jac, lower = prob$lower,
              upper = prob$upper)
print(prob$name)
print(c("convergence" = sol$convergence))
print(c("csolnp objective" = sol$objective, "best objective" = prob$best_fn))
print(sol$elapsed_time)
```

We also test a more specific problem based on the GARCH(1,1) model with analytic
derivatives:

```{r}
prob <- solnp_problem_suite(suite = "Other", number = 4)
sol <- csolnp(pars = prob$start, fn = prob$fn, gr = prob$gr, eq = prob$eq_fn, eq_b = prob$eq_b, 
              eq_jac = prob$eq_jac, ineq_fn = prob$ineq_fn, ineq_lower = prob$ineq_lower, 
              ineq_upper = prob$ineq_upper, ineq_jac = prob$ineq_jac, lower = prob$lower,
              upper = prob$upper)
print(prob$name)
print(c("convergence" = sol$convergence))
print(c("csolnp objective" = sol$objective, "best objective" = prob$best_fn))
print(sol$elapsed_time)
```

## Differences with full Active-Set/SQP solvers

Below is a short summary of the key differences between the SOLNP algorithm
and full Active-set/SQP methods:

| Aspect                | SOLNP                                    | Active-Set SQP / QP                  |
|-----------------------|------------------------------------------|--------------------------------------|
| Inequality handling   | Slacks, penalty, all treated equally     | Active set, complementarity enforced |
| Subproblem            | Least squares (QR, no QP)                | Quadratic programming                |
| KKT stationarity      | Not always enforced                      | Enforced at every step               |
| Complementarity       | Not enforced                             | Enforced at every step               |
| Scaling sensitivity   | Can be significant                       | Generally better                     |
| Globalization         | Penalty parameter tuning crucial         | Line search/trust region, more robust|
| Numerical behavior    | Simple, robust for easy problems         | More complex, better for hard ones   |



## Conclusion

The C++ rewrite of solnp, inclusion of analytic derivative options and the new
test suite should hopefully elevate the quality of the Rsolnp package. Future
enhancements will include expansion of the test suite, and a re-write of the
`gosolnp` functionality. 


